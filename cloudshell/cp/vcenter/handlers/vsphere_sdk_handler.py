#!/usr/bin/python
from __future__ import annotations

import re
import ssl
from logging import Logger

import attr
import requests
import urllib3
from com.vmware.cis.tagging_client import CategoryModel
from com.vmware.vapi.std.errors_client import AlreadyExists
from com.vmware.vapi.std_client import DynamicID
from packaging import version
from vmware.vapi.vsphere.client import VsphereClient, create_vsphere_client

from cloudshell.cp.core.reservation_info import ReservationInfo

from cloudshell.cp.vcenter.exceptions import TagFaultException
from cloudshell.cp.vcenter.handlers.si_handler import SiHandler
from cloudshell.cp.vcenter.handlers.vcenter_tag_handler import VCenterTagsManager
from cloudshell.cp.vcenter.resource_config import VCenterResourceConfig


@attr.s(auto_attribs=True, slots=True, frozen=True)
class VSphereSDKHandler:
    _vsphere_client: VsphereClient
    _tags_manager: VCenterTagsManager | None
    _logger: Logger

    # From this version vCenter works with vSphere SDK that allows to work with tags
    VCENTER_VERSION = "6.0.0"

    POSSIBLE_TYPES = [
        "Network",
        "HostNetwork",
        "OpaqueNetwork",
        "DistributedVirtualPortgroup" "VirtualMachine",
        "Folder",
    ]

    @classmethod
    def from_config(
        cls,
        resource_config: VCenterResourceConfig,
        reservation_info: ReservationInfo,
        logger: Logger,
    ) -> VSphereSDKHandler | None:
        si = SiHandler.from_config(resource_config, logger)
        if version.parse(si.vc_version) >= version.parse(cls.VCENTER_VERSION):
            logger.info("Initializing vSphere API client.")
            session = requests.session()
            session.verify = ssl.CERT_NONE
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            vsphere_client = create_vsphere_client(
                server=resource_config.address,
                username=resource_config.user,
                password=resource_config.password,
                session=session,
            )
            if reservation_info is not None:
                tags_manager = VCenterTagsManager(
                    resource_config=resource_config, reservation_info=reservation_info
                )
            else:
                tags_manager = None
            return cls(vsphere_client, tags_manager, logger)
        else:
            logger.warning(f"Tags available only from vCenter {cls.VCENTER_VERSION}")
            return

    def _get_all_categories(self) -> dict[str:str]:
        """Get all existing categories."""
        result = {}
        categories = self._vsphere_client.tagging.Category.list()
        if len(categories) > 0:
            self._logger.debug("List of all existing categories user has access to...")
            for category_id in categories:
                category_model = self._vsphere_client.tagging.Category.get(category_id)
                self._logger.debug(
                    f"CategoryName: {category_model.name}, "
                    f"CategoryID: {category_model.id}"
                )
                result.update({category_model.name: category_model.id})
        else:
            self._logger.info("No Tag Category Found...")

        return result

    def _get_or_create_tag_category(
        self,
        name: str,
        description: str = "Autogenerated by Cloudshell",
        cardinality: CategoryModel.Cardinality = CategoryModel.Cardinality.MULTIPLE,
    ) -> str:
        """Create a category or return an existing.

        Note: User who invokes this needs create category privilege
        """
        category_spec = self._vsphere_client.tagging.Category.CreateSpec()
        category_spec.name = name
        category_spec.description = description
        category_spec.cardinality = cardinality
        associableTypes = set(self.POSSIBLE_TYPES)
        category_spec.associable_types = associableTypes
        try:
            category_id = self._vsphere_client.tagging.Category.create(category_spec)
        except AlreadyExists:
            self._logger.debug(f"Tag Category {name} already exists.")
            category_id = self._get_all_categories().get(name)
            if category_id is None:
                raise TagFaultException("Error during tag category creation.")

        return category_id

    def create_categories(self, custom_categories: list | None):
        """Create all Default and Custom Tag Categories."""
        for tag_category in vars(VCenterTagsManager.DefaultTagNames):
            if not tag_category.startswith("__"):
                self._get_or_create_tag_category(
                    name=getattr(VCenterTagsManager.DefaultTagNames, tag_category)
                )

        if custom_categories:
            for custom_category in custom_categories:
                self._get_or_create_tag_category(name=custom_category)

    def _get_all_tags(self) -> dict[str:str]:
        """Get all existing tags."""
        result = {}
        tags = self._vsphere_client.tagging.Tag.list()
        if len(tags) > 0:
            self._logger.debug("List of all existing tags user has access to...")
            for tag_id in tags:
                tag_model = self._vsphere_client.tagging.Tag.get(tag_id)
                self._logger.debug(f"TagName: {tag_model.name}, TagID: {tag_model.id}")
                result.update({tag_model.name: tag_model.id})
        else:
            self._logger.info("No Tag Found...")

        return result

    def _get_or_create_tag(
        self, name: str, category_id: str, description: str = ""
    ) -> str:
        """Create a Tag."""
        tag_spec = self._vsphere_client.tagging.Tag.CreateSpec()
        tag_spec.name = name
        tag_spec.description = description
        tag_spec.category_id = category_id
        try:
            tag_id = self._vsphere_client.tagging.Tag.create(tag_spec)
        except AlreadyExists:
            self._logger.debug(f"Tag {name} already exists.")
            tag_id = self._get_all_tags().get(name)
            if tag_id is None:
                raise TagFaultException("Error during tag creation.")

        return tag_id

    def _create_multiple_tag_association(self, obj, tag_ids):
        """Attach tags."""
        object_id, object_type = self._get_object_id_and_type(obj)
        dynamic_id = DynamicID(type=object_type, id=object_id)
        self._vsphere_client.tagging.TagAssociation.attach_multiple_tags_to_object(
            tag_ids=tag_ids, object_id=dynamic_id
        )

    def assign_tags(self, obj, tags: dict[str:str] | None):
        """Get/Create tags and assign to provided vCenter object."""
        if not tags:
            tags = self._tags_manager.get_default_tags()

        tag_ids = []
        for category_name, tag in tags.items():
            category_id = self._get_or_create_tag_category(name=category_name)
            tag_id = self._get_or_create_tag(name=tag, category_id=category_id)
            tag_ids.append(tag_id)

        self._create_multiple_tag_association(obj=obj, tag_ids=tag_ids)

    def _get_attached_tags(self, obj):
        """Determine all tags attached to vCenter object."""
        object_id, object_type = self._get_object_id_and_type(obj)
        dynamic_id = DynamicID(type=object_type, id=object_id)
        tag_ids = self._vsphere_client.tagging.TagAssociation.list_attached_tags(
            dynamic_id
        )
        return tag_ids

    def _delete_tag_category(self, category_id):
        """Delete an existing tag category.

        User who invokes this API needs delete privilege on the tag category.
        """
        self._vsphere_client.tagging.Category.delete(category_id)

    def _delete_tag(self, tag_id):
        """Delete an existing tag.

        User who invokes this API needs delete privilege on the tag.
        """
        self._vsphere_client.tagging.Tag.delete(tag_id)

    def delete_tags(self, obj):
        """Delete tags if it used ONLY in current reservation."""
        tag_to_objects_mapping = {}
        pattern_objects_list = None
        for tag_id in self._get_attached_tags(obj=obj):
            tag_model = self._vsphere_client.tagging.Tag.get(tag_id)
            category_model = self._vsphere_client.tagging.Category.get(
                tag_model.category_id
            )
            self._logger.debug(f"TagID: {tag_id}, Category: {category_model.name}")
            if category_model.name == VCenterTagsManager.DefaultTagNames.sandbox_id:
                pattern_objects_list = (
                    self._vsphere_client.tagging.TagAssociation.list_attached_objects(
                        tag_id=tag_id
                    )
                )
                self._logger.debug(f"TagID to delete: {tag_id}")
                self._delete_tag(tag_id)
            else:
                tag_to_objects_mapping.update(
                    {
                        tag_id: self._vsphere_client.tagging.TagAssociation.list_attached_objects(  # noqa: E501
                            tag_id=tag_id
                        )
                    }
                )

        for tag_id, objects_list in tag_to_objects_mapping.items():
            if objects_list == pattern_objects_list:
                self._logger.debug(f"TagID to delete: {tag_id}")
                self._delete_tag(tag_id)

    def _get_object_id_and_type(self, obj):
        match = re.match(
            r"vim.(?P<object_type>\w+):(?P<object_id>\S+)", str(obj._entity).strip("'")
        )
        if match:
            object_id = match.groupdict().get("object_id")
            object_type = match.groupdict().get("object_type")
        else:
            raise TagFaultException(
                f"Can not determine object type. Object: {obj._entity}"
            )

        self._logger.debug(f"Object type: {object_type}, Object ID: {object_id}")
        return object_id, object_type
